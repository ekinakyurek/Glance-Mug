{
  "version": 3,
  "file": "filter.js",
  "sourceRoot": "",
  "sources": [
    "../../src/util/filter.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { copy, Stats } from \"fs-extra-p\"\nimport { Minimatch } from \"minimatch\"\nimport * as path from \"path\"\nimport { Promise as BluebirdPromise } from \"bluebird\"\nconst readInstalled = require(\"read-installed\")\n\n//noinspection JSUnusedLocalSymbols\nconst __awaiter = require(\"./awaiter\")\n\n// we use relative path to avoid canonical path issue - e.g. /tmp vs /private/tmp\nexport function copyFiltered(src: string, destination: string, filter: Filter, dereference: boolean): Promise<any> {\n  return copy(src, destination, {\n    dereference: dereference,\n    filter: <any>filter,\n    passStats: true,\n  })\n}\n\nexport function hasMagic(pattern: Minimatch) {\n  const set = pattern.set\n  if (set.length > 1) {\n    return true\n  }\n\n  for (let i of set[0]) {\n    if (typeof i !== \"string\") {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport type Filter = (file: string, stat: Stats) => boolean\n\nexport function createFilter(src: string, patterns: Array<Minimatch>, ignoreFiles?: Set<string>, rawFilter?: (file: string) => boolean, excludePatterns?: Array<Minimatch> | null): Filter {\n  return function filter(it, stat) {\n    if (src === it) {\n      return true\n    }\n\n    if (rawFilter != null && !rawFilter(it)) {\n      return false\n    }\n\n    // yes, check before path sep normalization\n    if (ignoreFiles != null && ignoreFiles.has(it)) {\n      return false\n    }\n\n    let relative = it.substring(src.length + 1)\n\n    if (path.sep === \"\\\\\") {\n      relative = relative.replace(/\\\\/g, \"/\")\n    }\n\n    return minimatchAll(relative, patterns, stat) && (excludePatterns == null || !minimatchAll(relative, excludePatterns, stat))\n  }\n}\n\nexport function devDependencies(dir: string): Promise<Array<string>> {\n  return new BluebirdPromise((resolve, reject) => {\n    readInstalled(dir, (error: Error, data: any) => {\n      if (error) {\n        reject(error)\n      }\n      else {\n        resolve(flatDependencies(data, new Set()))\n      }\n    })\n  })\n}\n\nfunction flatDependencies(data: any, seen: Set<string>): any {\n  const deps = data.dependencies\n  if (deps == null) {\n    return []\n  }\n\n  return Object.keys(deps).map(function (d) {\n    if (typeof deps[d] !== \"object\" || seen.has(deps[d])) {\n      return null\n    }\n\n    seen.add(deps[d])\n    if (deps[d].extraneous) {\n      const extra = deps[d]\n      delete deps[d]\n      return extra.path\n    }\n    return flatDependencies(deps[d], seen)\n  })\n    .filter(it => it !== null)\n    .reduce(function flat(l, r): Array<string> {\n      return l.concat(Array.isArray(r) ? r.reduce(flat, []) : r)\n    }, [])\n\n}\n\n// https://github.com/joshwnj/minimatch-all/blob/master/index.js\nfunction minimatchAll(path: string, patterns: Array<Minimatch>, stat: Stats): boolean {\n  let match = false\n  for (let pattern of patterns) {\n    // If we've got a match, only re-test for exclusions.\n    // if we don't have a match, only re-test for inclusions.\n    if (match !== pattern.negate) {\n      continue\n    }\n\n    // partial match — pattern: foo/bar.txt path: foo — we must allow foo\n    // use it only for non-negate patterns: const m = new Minimatch(\"!node_modules/@(electron-download|electron)/**/*\", {dot: true }); m.match(\"node_modules\", true) will return false, but must be true\n    match = pattern.match(path, stat.isDirectory() && !pattern.negate)\n  }\n  return match\n}"
  ]
}
